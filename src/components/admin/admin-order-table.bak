import React from "react"
import {
  ColumnDef,
  flexRender,
  getCoreRowModel,
  useReactTable,
} from "@tanstack/react-table"

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { OrderStatusUpdate } from "./order-status-update"
import { Button } from "@/components/ui/button"
// Input is imported but not currently used directly in the rendered JSX
// Keeping import for future reference
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
// Trash2 icon is imported but not currently used directly in the rendered JSX
// Keeping import for future reference
import { Trash2 } from "lucide-react"
// Dialog components are imported but not currently used in this file
// Keeping the import commented for future reference
// import {
//   Dialog,
//   DialogContent,
//   DialogHeader,
//   DialogTitle,
//   DialogTrigger,
// } from "@/components/ui/dialog"
import { toast } from "@/hooks/use-toast"
import { getSupabaseClient, supabaseAdmin } from '@/lib/supabase';
import type { Order, OrderItem } from "@/types/order"
import { fetchProductCodes, getProductCode } from "@/lib/product-utils"
import { useAuth, useUser } from "@clerk/clerk-react"

interface AdminOrderTableProps {
  orders: Order[];
  reloadOrders: () => Promise<void>;
  loading: boolean;
}

interface ProductCategory {
  id: string
  name: string
  products: Product[]
}

interface Product {
  id: string
  name: string
  price: number
  category_id: string
}

export function AdminOrderTable({ orders, reloadOrders, loading }: AdminOrderTableProps): JSX.Element {
  // Use Clerk's auth state to ensure user is signed in
  const { isSignedIn } = useUser();
  const { userId } = useAuth();
  const supabase = getSupabaseClient(); // Initialize Supabase client
  const [expandedOrderId, setExpandedOrderId] = React.useState<string | null>(null);
  const [editingItems, setEditingItems] = React.useState<{ [key: string]: OrderItem[] }>({});
  const [adminNotes, setAdminNotes] = React.useState<{ [key: string]: string }>({});
  const [isSaving, setIsSaving] = React.useState(false);
  const [productCodes, setProductCodes] = React.useState<Record<string, {code: string, category: string}>>({});
  
  // The following state variables are kept for future implementation but not currently used
  // They're needed for the product selection/filtering functionality
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [categories, setCategories] = React.useState<ProductCategory[]>([]);
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [selectedCategory, setSelectedCategory] = React.useState<string | null>(null);
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [selectedProductForOrder, setSelectedProductForOrder] = React.useState<string | null>(null);

  // Add more detailed logging about the orders received
  console.log('AdminOrderTable - orders received:', orders);
  if (orders.length > 0) {
    console.log('AdminOrderTable - first order full data:', orders[0]);
    console.log('AdminOrderTable - first order properties:', orders[0] ? Object.keys(orders[0]) : []);
  }
  // Add specific debugging for the status of each order
  orders.forEach(order => {
    console.log(`Order ${order.id} status: ${order.status}`);
  });

  const formatCurrency = (amount: number) => {
    return `R ${amount.toLocaleString()}`;
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString();
  };

  // Load categories and products when component mounts and user is signed in
  React.useEffect(() => {
    // Only load categories when user is signed in (Clerk is initialized)
    if (isSignedIn) {
      loadCategories();
    }
  }, [isSignedIn]);

  const loadCategories = async () => {
    try {
      // Define our category tables with their specific column mappings
      const categoryTables = [
        { 
          id: 'mattress', 
          name: 'Mattresses', 
          table: 'mattress',
          nameField: 'description',
          priceField: 'set_price',
          codeField: 'mattress_code'
        },
        { 
          id: 'furniture', 
          name: 'Furniture', 
          table: 'furniture',
          nameField: 'description',
          priceField: 'price',
          codeField: 'code'
        },
        { 
          id: 'headboards', 
          name: 'Headboards', 
          table: 'headboards',
          nameField: 'description',
          priceField: 'price',
          codeField: 'code'
        },
        { 
          id: 'accessories', 
          name: 'Accessories', 
          table: 'accessories',
          nameField: 'description',
          priceField: 'price',
          codeField: 'code'
        },
        { 
          id: 'foam', 
          name: 'Foam', 
          table: 'foam',
          nameField: 'description',
          priceField: 'price',
          codeField: 'code'
        }
      ];

      // Fetch products from each category table
      const categoriesWithProducts = await Promise.all(
        categoryTables.map(async (category) => {
          // Check if supabase client is initialized
          if (!supabase) {
            console.error('Supabase client not initialized when loading categories');
            return {
              id: category.id,
              name: category.name,
              products: []
            };
          }

          const { data, error } = await supabase
            .from(category.table)
            .select(`
              id,
              ${category.nameField},
              ${category.priceField},
              ${category.codeField}
            `);

          if (error) {
            console.error(`Error loading ${category.name}:`, error);
            return {
              id: category.id,
              name: category.name,
              products: []
            };
          }

          return {
            id: category.id,
            name: category.name,
            products: data.map((product: any) => ({
              id: product.id,
              name: `${product[category.codeField]} - ${product[category.nameField]}`,
              price: product[category.priceField],
              category_id: category.id
            }))
          };
        })
      );

      const validCategories = categoriesWithProducts.filter(cat => cat.products.length > 0);
      setCategories(validCategories);
      
      // Select first category with products by default
      if (validCategories.length > 0) {
        setSelectedCategory(validCategories[0].id);
      }
    } catch (err: any) {
      console.error('Error loading categories:', err);
      toast({
        title: "Error",
        description: "Failed to load products: " + (err.message || 'Unknown error'),
        variant: "destructive",
      });
    }
  };

  const initializeOrderEdit = (order: Order) => {
    if (!editingItems[order.id]) {
      setEditingItems({
        ...editingItems,
        [order.id]: [...(order.items || [])]
      });
      setAdminNotes({
        ...adminNotes,
        [order.id]: ""
      });
    }
  };

  // Function to update item quantity - currently used in the order items table
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const handleQuantityChange = (orderId: string, itemId: string, newQuantity: number) => {
    if (newQuantity < 1) return;

    setEditingItems(currentItems => {
      const orderItems = [...(currentItems[orderId] || [])];
      const itemIndex = orderItems.findIndex(item => item.id === itemId);
      
      if (itemIndex !== -1) {
        orderItems[itemIndex] = { ...orderItems[itemIndex], quantity: newQuantity };
      }
      
      return { ...currentItems, [orderId]: orderItems };
    });
  };

  // Function to remove an item from an order - currently used in the order items table
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const handleDeleteItem = (orderId: string, itemId: string) => {
    setEditingItems(currentItems => {
      const orderItems = currentItems[orderId]?.filter(item => item.id !== itemId) || [];
      return { ...currentItems, [orderId]: orderItems };
    });
  };

  // Function to add a new product to an order - not currently used but kept for future implementation
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const handleAddItem = (orderId: string, product: Product) => {
    const newItem: OrderItem = {
      id: `temp_${Date.now()}`, // Temporary ID, will be replaced on save
      product_id: product.id,
      product_name: product.name,
      price: product.price,
      quantity: 1,
      total: product.price,
      order_id: orderId,
      stock_item_id: product.id // Assuming product.id can be used as stock_item_id
    };

    setEditingItems(current => {
      const items = current[orderId] || [];
      return {
        ...current,
        [orderId]: [...items, newItem]
      };
    });

    toast({
      title: "Item Added",
      description: `Added ${product.name} to order`,
    });
  };

  const handleStartEditing = (order: Order) => {
    initializeOrderEdit(order);
  };

  const handleDiscard = (orderId: string) => {
    setEditingItems(current => {
      const { [orderId]: _, ...rest } = current;
      return rest;
    });
    setAdminNotes(current => {
      const { [orderId]: _, ...rest } = current;
      return rest;
    });
    toast({
      title: "Changes Discarded",
      description: "All changes have been discarded",
    });
  };

  const calculateTotals = (items: OrderItem[]) => {
    return items.reduce((acc, item) => ({
      quantity: acc.quantity + item.quantity,
      value: acc.value + item.total
    }), { quantity: 0, value: 0 });
  };

  const handleSave = async (order: Order) => {
    try {
      setIsSaving(true);
      const editedOrderItems = editingItems[order.id];
      if (!editedOrderItems) {
        toast({ title: "No changes", description: "No items were modified.", variant: "default" });
        setIsSaving(false);
        return;
      }

      const originalOrderItems = order.items || [];
      const newTotals = calculateTotals(editedOrderItems);
      
      // Use Clerk auth with proper hooks
      if (!isSignedIn || !userId) {
        toast({ title: "Authentication Error", description: "Please sign in again to continue.", variant: "destructive" });
        setIsSaving(false);
        throw new Error("Authentication error. Please log in again.");
      }
      // Get clerk user ID from the useAuth hook

      // 1. Create a single order_history entry for this edit session
      // Use supabaseAdmin for privileged operations to bypass RLS
      if (!supabaseAdmin) {
        console.error('SupabaseAdmin client not initialized for order history');
        toast({ title: "Admin Error", description: "Admin database client not available", variant: "destructive" });
        setIsSaving(false);
        return;
      }
      
      console.log('Using supabaseAdmin client for order_history operations');
      const { data: historyEntryResult, error: historyEntryError } = await supabaseAdmin
        .from('order_history')
        .insert({
          order_id: order.id,
          // Store Clerk user ID in details JSON field to avoid UUID format issues
          details: {
            clerk_user_id: userId
          },
          changed_by: null, // Use null for user_id UUID column
          change_type: 'items_modified', // General type for item edits
          notes: adminNotes[order.id] || '',
          previous_status: order.status, // Store current status
          new_status: 'review', // Standard practice to set to review after admin edit
          metadata: {
            original_quantity: order.quantity,
            updated_quantity: newTotals.quantity,
            original_value: order.value,
            updated_value: newTotals.value,
          }
        })
        .select('id')
        .single();

      if (historyEntryError || !historyEntryResult) {
        console.error('Failed to create order_history entry:', historyEntryError);
        toast({ title: "Error", description: "Failed to log high-level order changes.", variant: "destructive" });
        setIsSaving(false);
        return;
      }
      const orderHistoryId = historyEntryResult.id;
      
      const itemHistoryEntries: any[] = [];

      // 2. Process item changes (Added, Modified, Removed)

      // Identify new (added), existing (potentially modified), and removed items
      const newItemsToInsert: OrderItem[] = [];
      const existingItemsToUpdate: OrderItem[] = [];
      const removedItemOriginalDetails: OrderItem[] = [];

      // Populate newItemsToInsert and existingItemsToUpdate from editedOrderItems
      for (const editedItem of editedOrderItems) {
        if (editedItem.id.startsWith('temp_')) {
          newItemsToInsert.push(editedItem);
        } else {
          const originalItem = originalOrderItems.find(oi => oi.id === editedItem.id);
          if (originalItem) {
            // Check if actually modified
            if (originalItem.quantity !== editedItem.quantity || originalItem.price !== editedItem.price) {
              existingItemsToUpdate.push(editedItem); // It's an update to an existing item
               itemHistoryEntries.push({
                order_history_id: orderHistoryId,
                order_item_id: originalItem.id,
                stock_item_id: originalItem.stock_item_id,
                product_name: editedItem.product_name,
                previous_quantity: originalItem.quantity,
                new_quantity: editedItem.quantity,
                previous_price: originalItem.price,
                new_price: editedItem.price,
                action: 'modified'
              });
            }
            // If not modified, it's just carried over, no history entry needed unless other fields can change
          } else {
            // This case should ideally not happen if temp_ IDs are used for all new items
            console.warn("Edited item not found in original items and not a temp_ item:", editedItem);
          }
        }
      }
      
      // Identify removed items
      originalOrderItems.forEach(originalItem => {
        const stillExists = editedOrderItems.find(ei => ei.id === originalItem.id);
        if (!stillExists) {
          removedItemOriginalDetails.push(originalItem);
          itemHistoryEntries.push({
            order_history_id: orderHistoryId,
            order_item_id: originalItem.id,
            stock_item_id: originalItem.stock_item_id,
            product_name: originalItem.product_name,
            previous_quantity: originalItem.quantity,
            new_quantity: 0, // Effectively removed
            previous_price: originalItem.price,
            new_price: originalItem.price, // Price is irrelevant as it's removed
            action: 'removed'
          });
        }
      });

      // 3. Perform database operations for items

      // A. Insert new items into 'order_items' and capture their new IDs for history
      if (newItemsToInsert.length > 0) {
        const itemsToInsertForDB = newItemsToInsert.map(item => ({
          order_id: order.id,
          product_id: item.product_id,
          product_name: item.product_name,
          price: item.price,
          quantity: item.quantity,
          total: item.total,
          stock_item_id: item.stock_item_id,
          // any other necessary fields for order_items
        }));

        // Check if admin client is initialized
      if (!supabaseAdmin) {
        console.error('SupabaseAdmin client not initialized when inserting order items');
        throw new Error('Database client not available. Please try again.');
      }

      const { data: insertedItemsData, error: insertNewItemsError } = await supabaseAdmin
          .from('order_items')
          .insert(itemsToInsertForDB)
          .select('id, product_name'); // Select enough to match back

      if (insertNewItemsError) {
        console.error('Failed to insert new order items:', insertNewItemsError);
        toast({ title: "Error", description: "Failed to save new items to your order.", variant: "destructive" });
        setIsSaving(false);
        return;
      }

      // Update local temp IDs to real database IDs for history entries
      if (insertedItemsData && insertedItemsData.length > 0) {
        insertedItemsData.forEach((dbItem: any) => {
          // Find the corresponding temp item in newItemsToInsert to link its history
          // This matching might need to be more robust, e.g., if product_name isn't unique
          const tempItemDetails = newItemsToInsert.find(
            temp => temp.product_name === dbItem.product_name && temp.order_id === order.id
          );
          if(tempItemDetails){
            itemHistoryEntries.push({
              order_history_id: orderHistoryId,
              order_item_id: dbItem.id, // The new database ID
              stock_item_id: tempItemDetails.stock_item_id,
              product_name: tempItemDetails.product_name,
              previous_quantity: 0,
              new_quantity: tempItemDetails.quantity,
              previous_price: 0,
              new_price: tempItemDetails.price,
              action: 'added'
            });
          }
        });
      }

      // B. Update existing items in 'order_items'
      for (const itemToUpdate of existingItemsToUpdate) {
        // Check if supabaseAdmin client is initialized
        if (!supabaseAdmin) {
          console.error('SupabaseAdmin client not initialized when updating order items');
          throw new Error('Database client not available. Please try again.');
        }

        const { error: updateItemError } = await supabaseAdmin
          .from('order_items')
          .update({
            quantity: itemToUpdate.quantity,
            price: itemToUpdate.price,
            total: itemToUpdate.price * itemToUpdate.quantity
          })
          .eq('id', itemToUpdate.id);

        if (updateItemError) {
          console.error('Error updating order item:', itemToUpdate.id, updateItemError);
          // Decide on error handling: continue or throw?
          // For now, we'll log and continue, but this could lead to partial updates.
          toast({title: "Warning", description: `Failed to update item ${itemToUpdate.product_name}.`, variant: "destructive"})
        }
      }
      
      // C. Delete removed items from 'order_items'
      const removedItemIds = removedItemOriginalDetails.map(item => item.id);
      if (removedItemIds.length > 0) {
        // Check if supabaseAdmin client is initialized
        if (!supabaseAdmin) {
          console.error('SupabaseAdmin client not initialized when deleting order items');
          throw new Error('Database client not available. Please try again.');
        }

        const { error: deleteItemsError } = await supabaseAdmin
          .from('order_items')
          .delete()
          .in('id', removedItemIds);

        if (deleteItemsError) {
          console.error('Error deleting order items:', deleteItemsError);
          throw new Error('Failed to remove items from order.');
        }
      }

      // 4. Insert all collected itemHistoryEntries
      if (itemHistoryEntries.length > 0) {
        // Check if supabaseAdmin client is initialized
        if (!supabaseAdmin) {
          console.error('SupabaseAdmin client not initialized when inserting order item history');
          throw new Error('Database client not available. Please try again.');
        }

        const { error: itemHistoryError } = await supabaseAdmin
          .from('order_item_history')
          .insert(itemHistoryEntries);

        if (itemHistoryError) {
          console.error('Failed to save detailed order_item_history:', itemHistoryError);
          toast({ title: "Warning", description: "Order items updated, but detailed history logging failed.", variant: "destructive" });
        }
      }

      // 5. Update the main 'orders' table (totals, status, etc.)
      // Check if admin client is initialized
      if (!supabaseAdmin) {
        console.error('Supabase client not initialized when updating orders');
        throw new Error('Database client not available. Please try again.');
      }

      const { error: updateOrderError } = await supabaseAdmin
        .from('orders')
        .update({
          status: 'review', // Always set to review after admin edit
          quantity: newTotals.quantity,
          value: newTotals.value,
          // Potentially update order.items if it's a snapshot, though individual items are now in order_items
          // If order.items is used as the source of truth for display, it needs to be updated here
          // with the full `editedOrderItems` list (after new items have real IDs).
          // This is complex if new item IDs are generated by the DB.
          // For simplicity, let's assume order display will reconstruct from order_items.
        })
        .eq('id', order.id);

      if (updateOrderError) {
        console.error('Error updating main order record:', updateOrderError);
        throw new Error('Failed to update order summary.');
      }

      toast({
        title: "Order Updated",
        description: `Order ${order.order_number} has been updated and set for customer review.`,
      });

      // Clear editing state for this order
      setEditingItems(current => {
        const { [order.id]: _, ...rest } = current;
        return rest;
      });
      setAdminNotes(current => {
        const { [order.id]: _, ...rest } = current;
        return rest;
      });
      
      reloadOrders(); // Refresh the order list
    } catch (error: any) {
      console.error('Error updating order:', error);
      
      // General error handling
      toast({
        title: "Error",
        description: error.message || "Failed to update order",
        variant: "destructive",
      });
    } finally {
      setIsSaving(false);
    }
  };

  const columns: ColumnDef<Order>[] = [
    {
      accessorKey: "order_number",
      header: "Order",
    },
    {
      accessorKey: "created_at",
      header: "Date",
      cell: ({ row }) => formatDate(row.getValue("created_at")),
    },
    {
      accessorKey: "store_name",
      header: "Store",
      cell: ({ row }) => row.getValue("store_name") || "N/A",
    },
    {
      accessorKey: "owner_name",
      header: "Customer",
      cell: ({ row }) => {
        const value = row.getValue("owner_name");
        return value || "N/A";
      },
    },
    {
      accessorKey: "status",
      header: "Status",
      cell: ({ row }) => {
        const order = row.original;
        return (
          <OrderStatusUpdate
            orderId={order.id}
            currentStatus={order.status || 'pending'}
            onStatusUpdated={reloadOrders}
          />
        );
      },
    },
    {
      accessorKey: "quantity",
      header: "Qty",
      cell: ({ row }) => {
        const quantity = row.getValue("quantity") as number;
        return quantity?.toLocaleString() || "0"
      },
    },
    {
      accessorKey: "value",
      header: "Value",
      cell: ({ row }) => {
        const value = row.getValue("value") as number;
        return value ? formatCurrency(value) : "R 0"
      },
    },
  ];

  const table = useReactTable({
    data: orders,
    columns,
    getCoreRowModel: getCoreRowModel(),
  })

  // Load product codes for expanded order items
  React.useEffect(() => {
    if (expandedOrderId && editingItems[expandedOrderId]) {
      // Get all stock_item_ids from the expanded order
      const stockItemIds = editingItems[expandedOrderId]
        .map(item => item.stock_item_id)
        .filter(Boolean);
      
      console.log('Stock item IDs to fetch codes for:', stockItemIds);
      
      if (stockItemIds.length > 0) {
        // Load product codes using our utility function
        const loadProductCodes = async () => {
          try {
            const codes = await fetchProductCodes(stockItemIds);
            console.log('Product codes fetched:', codes);
            setProductCodes(prev => ({
              ...prev,
              ...codes
            }));
          } catch (err) {
            console.error('Error loading product codes:', err);
          }
        };
        
        loadProductCodes();
      }
    }
  }, [expandedOrderId, editingItems]);

  const toggleOrderItems = (orderId: string, order: Order) => {
    if (expandedOrderId !== orderId) {
      initializeOrderEdit(order);
    }
    setExpandedOrderId(expandedOrderId === orderId ? null : orderId);
  };

  return (
    <div className="rounded-md border">
      <Table>
        <TableHeader>
          <TableRow>
            {table.getHeaderGroups()[0].headers.map((header) => (
              <TableHead key={header.id}>
                {header.isPlaceholder
                  ? null
                  : flexRender(
                      header.column.columnDef.header,
                      header.getContext()
                    )}
              </TableHead>
            ))}
          </TableRow>
        </TableHeader>
        <TableBody>
          {table.getRowModel().rows?.length ? (
            table.getRowModel().rows.map((row) => (
              <React.Fragment key={row.id}>
                <TableRow
                  data-state={row.getIsSelected() && "selected"}
                  className="cursor-pointer hover:bg-muted/50"
                  onClick={() => toggleOrderItems(row.original.id, row.original)}
                >
                  {row.getVisibleCells().map((cell) => (
                    <TableCell key={cell.id} className="py-4">
                      {flexRender(cell.column.columnDef.cell, cell.getContext())}
                    </TableCell>
                  ))}
                </TableRow>
                {/* Expandable Line Items Section */}
                {expandedOrderId === row.original.id && (
                  <TableRow 
                    className="bg-muted/50"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <TableCell colSpan={columns.length} className="p-0">
                      <div className="p-6 space-y-6">
                        <div className="flex justify-between items-center">
                          <h4 className="text-sm font-medium">Line Items</h4>
                          <Button 
                            size="sm"
                            onClick={() => handleStartEditing(row.original)}
                          >
                            Edit Order
                          </Button>
                        </div>

                        {expandedOrderId === row.original.id && (
                          <>
                            <Table>
                              <TableHeader>
                                <TableRow>
                                  <TableHead>Code</TableHead>
                                  <TableHead>Product</TableHead>
                                  <TableHead className="text-right">Price</TableHead>
                                  <TableHead className="text-right w-[150px]">Qty</TableHead>
                                  <TableHead className="text-right">Total</TableHead>
                                  <TableHead className="w-[70px]"></TableHead>
                                </TableRow>
                              </TableHeader>
                              <TableBody>
                                {editingItems[row.original.id]?.map((item: OrderItem, index) => (
                                  <TableRow key={item.id || index}>
                                    <TableCell>
                                      {/* Use the same getProductCode function that works in the customer view */}
                                      {getProductCode(item, productCodes)}
                                    </TableCell>
                                    <TableCell>{item.product_name}</TableCell>
                                    <TableCell className="text-right">
                                      {formatCurrency(item.price)}
                                    </TableCell>
                                    <TableCell className="text-right">
                                      <Input 
                                        type="number" 
                                        min="1"
                                        value={item.quantity}
                                        onChange={(e) => handleQuantityChange(
                                          row.original.id, 
                                          item.id || '', 
                                          parseInt(e.target.value) || 1
                                        )}
                                        className="w-20 inline-block" 
                                      />
                                    </TableCell>
                                    <TableCell className="text-right">
                                      {formatCurrency(item.price * item.quantity)}
                                    </TableCell>
                                    <TableCell>
                                      <Button 
                                        variant="ghost" 
                                        size="icon" 
                                        onClick={() => handleDeleteItem(row.original.id, item.id || '')}
                                      >
                                        <Trash2 className="h-4 w-4" />
                                      </Button>
                                    </TableCell>
                                  </TableRow>
                                ))}
                              </TableBody>
                            </Table>
                            
                            <div className="mt-6 space-y-4">
                              <div className="space-y-2">
                                <label className="text-sm font-medium">
                                  Admin Notes
                                </label>
                                <Textarea
                                  value={adminNotes[row.original.id] || ""}
                                  onChange={(e) => setAdminNotes(current => ({
                                    ...current,
                                    [row.original.id]: e.target.value
                                  }))}
                                  placeholder="Enter notes about the changes..."
                                  className="min-h-[100px]"
                                />
                              </div>

                              <div className="flex justify-end gap-4">
                                <Button
                                  variant="outline"
                                  onClick={() => handleDiscard(row.original.id)}
                                  disabled={loading}
                                >
                                  Discard Changes
                                </Button>
                                <Button
                                  onClick={() => handleSave(row.original)}
                                  disabled={isSaving || loading}
                                >
                                  {isSaving ? "Saving..." : "Save Changes"}
                                </Button>
                              </div>
                            </div>
                          </>
                        )}
                      </div>
                    </TableCell>
                  </TableRow>
                )}
              </React.Fragment>
            ))
          ) : (
            <TableRow>
              <TableCell colSpan={columns.length} className="h-24 text-center">
                No results.
              </TableCell>
            </TableRow>
          )}
        </TableBody>
      </Table>
    </div>
  )
} 